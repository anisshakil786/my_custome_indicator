// This Pine Script™ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © Muhammad_Anis

//@version=6
indicator("All in One", "AIO", true, max_lines_count = 500, max_boxes_count = 1000)

get_line_type(_style) =>
    switch _style
        'Solid' => line.style_solid
        'Dotted' => line.style_dotted
        'Dashed' => line.style_dashed

get_size(x) =>
    switch x
        'Auto' => size.auto
        'Tiny' => size.tiny
        'Small' => size.small
        'Normal' => size.normal
        'Large' => size.large
        'Huge' => size.huge

type kz
    string _title
    box[] _box
    line[] _hi_line
    line[] _md_line
    line[] _lo_line
    bool[] _hi_valid
    bool[] _md_valid
    bool[] _lo_valid

type hz
    line[] LN
    label[] LB
    bool[] CO

type dwm_hl
    line[] hi_line
    line[] lo_line
    label[] hi_label
    label[] lo_label
    bool hit_high = false
    bool hit_low = false

type dwm_info
    string tf
    float o = na
    float h = na
    float l = na
    float ph = na
    float pl = na

type Candle
	float o
	float c
	float h
	float l
    int o_time
	int o_idx
	int c_idx
	int h_idx
	int l_idx
    string dow
	box body
	line wick_up
	line wick_down
    label dow_label

type Trace
	line o
	line c
	line h
	line l
	label o_l
	label c_l
	label h_l
	label l_l

type Imbalance
	box b
	int idx

type CandleSettings
	bool show
	string htf
	int max_display

type Settings
	int max_sets
	color bull_body
	color bull_border
	color bull_wick
	color bear_body
	color bear_border
	color bear_wick
	int offset
	int buffer
	int htf_buffer
	int width
	bool use_custom_daily
    string custom_daily
    bool daily_name
	bool trace_show
	color trace_o_color
	string trace_o_style
	int trace_o_size
	color trace_c_color
	string trace_c_style
	int trace_c_size
	color trace_h_color
	string trace_h_style
	int trace_h_size
	color trace_l_color
	string trace_l_style
	int trace_l_size
	string trace_anchor
	bool label_show
	color label_color
	string label_size
    string label_position
    string label_alignment
	bool fvg_show
	color fvg_color
	bool vi_show
	color vi_color
	bool htf_label_show
	color htf_label_color
	string htf_label_size
	bool htf_timer_show
	color htf_timer_color
	string htf_timer_size
    color dow_color
    string dow_size

type CandleSet
	array<Candle> candles
	array<Imbalance> imbalances
	CandleSettings settings
	label tfNameTop
    label tfNameBottom
	label tfTimerTop
    label tfTimerBottom

type Helper
	string name = 'Helper'

Settings settings = Settings.new()

var CandleSettings SettingsHTF1 = CandleSettings.new()
var CandleSettings SettingsHTF2 = CandleSettings.new()
var CandleSettings SettingsHTF3 = CandleSettings.new()
var CandleSettings SettingsHTF4 = CandleSettings.new()
var CandleSettings SettingsHTF5 = CandleSettings.new()
var CandleSettings SettingsHTF6 = CandleSettings.new()

var array<Candle> candles_1 = array.new<Candle>(0)
var array<Candle> candles_2 = array.new<Candle>(0)
var array<Candle> candles_3 = array.new<Candle>(0)
var array<Candle> candles_4 = array.new<Candle>(0)
var array<Candle> candles_5 = array.new<Candle>(0)
var array<Candle> candles_6 = array.new<Candle>(0)

var array<Imbalance> imbalances_1 = array.new<Imbalance>()
var array<Imbalance> imbalances_2 = array.new<Imbalance>()
var array<Imbalance> imbalances_3 = array.new<Imbalance>()
var array<Imbalance> imbalances_4 = array.new<Imbalance>()
var array<Imbalance> imbalances_5 = array.new<Imbalance>()
var array<Imbalance> imbalances_6 = array.new<Imbalance>()

var hz_h1 = hz.new(array.new_line(), array.new_label(), array.new_bool())
var hz_h2 = hz.new(array.new_line(), array.new_label(), array.new_bool())

var d_hl = dwm_hl.new(array.new_line(), array.new_line(), array.new_label(), array.new_label())
var w_hl = dwm_hl.new(array.new_line(), array.new_line(), array.new_label(), array.new_label())
var m_hl = dwm_hl.new(array.new_line(), array.new_line(), array.new_label(), array.new_label())

var d_info = dwm_info.new("D")
var w_info = dwm_info.new("W")
var m_info = dwm_info.new("M")

var d_sep_line = array.new_line()
var w_sep_line = array.new_line()
var m_sep_line = array.new_line()

var d_line = array.new_line()
var w_line = array.new_line()
var m_line = array.new_line()

var d_label = array.new_label()
var w_label = array.new_label()
var m_label = array.new_label()

var CandleSet htf1 = CandleSet.new()
htf1.settings := SettingsHTF1
htf1.candles := candles_1
htf1.imbalances := imbalances_1

var CandleSet htf2 = CandleSet.new()
htf2.settings := SettingsHTF2
htf2.candles := candles_2
htf2.imbalances := imbalances_2

var CandleSet htf3 = CandleSet.new()
htf3.settings := SettingsHTF3
htf3.candles := candles_3
htf3.imbalances := imbalances_3

var CandleSet htf4 = CandleSet.new()
htf4.settings := SettingsHTF4
htf4.candles := candles_4
htf4.imbalances := imbalances_4

var CandleSet htf5 = CandleSet.new()
htf5.settings := SettingsHTF5
htf5.candles := candles_5
htf5.imbalances := imbalances_5

var CandleSet htf6 = CandleSet.new()
htf6.settings := SettingsHTF6
htf6.candles := candles_6
htf6.imbalances := imbalances_6

var float ma1 = na
var float ma2 = na
var float ma3 = na
var float ma4 = na

string g_settings              = "Settings  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string g_snkz                  = "Sessions and Killzones  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string g_killzones             = "Killzones  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string g_htfcandles            = "HTF Candles  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string g_label                 = "HTF Label Settings  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string g_imbalance             = "HTF Imbalance  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string g_trace                 = "HTF Trace  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string g_dwm                   = "Previous Period H/L  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string g_ma                    = "MA  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
string g_extraoptions          = "Extra Options  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

enable_sessionsandkillzones = input.bool(true, "Enable Sessions and Killzones")
enable_htf                  = input.bool(true, "Enable HTF Candles")
enable_dwm                  = input.bool(true, "Enable Day - Week - Month")
enable_ma                   = input.bool(true, "Enable MA")
enable_extra_options        = input.bool(true, "Enable Extra Options")

max_days                    = input.int(1, "Session Drawing Limit", minval=1, maxval=30, tooltip = "Only this many drawings will be kept on the chart, for each selected drawing type (killzone boxes, pivot lines, open lines, etc.)", group = g_settings)
tf_limit                    = input.timeframe("30", "Timeframe Limit", tooltip = "Drawings will not appear on timeframes greater than or equal to this", group = g_settings)
gmt_tz                      = input.string('America/New_York', "Timezone", options = ['America/New_York', 'GMT-12', 'GMT-11', 'GMT-10', 'GMT-9', 'GMT-8', 'GMT-7', 'GMT-6', 'GMT-5', 'GMT-4', 'GMT-3', 'GMT-2', 'GMT-1', 'GMT+0', 'GMT+1', 'GMT+2', 'GMT+3', 'GMT+4', 'GMT+5', 'GMT+6', 'GMT+7', 'GMT+8', 'GMT+9', 'GMT+10', 'GMT+11', 'GMT+12', 'GMT+13', 'GMT+14'], tooltip = "Note GMT is not adjusted to reflect Daylight Saving Time changes", group = g_settings)
lbl_size                    = get_size(input.string('Small', "Label Size", options = ['Auto', 'Tiny', 'Small', 'Normal', 'Large', 'Huge'], tooltip = "The size of all labels", group = g_settings))
txt_color                   = input.color(color.black, "Text Color", tooltip = "The color of all label and table text", group = g_settings)
use_cutoff                  = input.bool(true, "Drawing Cutoff Time", inline = "CO", tooltip = "When enabled, all pivots and open price lines will stop extending at this time", group = g_settings)
cutoff                      = input.session("1800-1801", "", inline = "CO", group = g_settings)

use_asian_session           = input.bool(true, "Asian Session", inline = "ASIAN_SESSION", group = g_snkz)
as_txt                      = ""
asian_session               = input.session("1800-0400", "", inline = "ASIAN_SESSION", group = g_snkz)
as_color                    = input.color(#00bcd4, "", inline = "ASIAN_SESSION", group = g_snkz)

use_london_session          = input.bool(true, "London Session", inline = "LONDON_SESSION", group = g_snkz)
ls_txt                      = ""
london_session              = input.session("0300-1200", "", inline = "LONDON_SESSION", group = g_snkz)
ls_color                    = input.color(#2962ff, "", inline = "LONDON_SESSION", group = g_snkz)

use_newyork_session         = input.bool(true, "NewYork Session", inline = "NEWYORK_SESSION", group = g_snkz)
nys_txt                     = ""
newyork_session             = input.session("0800-1600", "", inline = "NEWYORK_SESSION", group = g_snkz)
nys_color                   = input.color(#089981, "", inline = "NEWYORK_SESSION", group = g_snkz)

use_asia_killzone           = input.bool(true, "", inline = "ASIA", group = g_snkz)
ak_txt                      = input.string("Asia", "", inline = "ASIA", group = g_snkz)
asia                        = input.session("2000-0000", "", inline = "ASIA", group = g_snkz)
ak_color                    = input.color(#000000, "", inline = "ASIA", group = g_snkz)

use_london_killzone         = input.bool(true, "", inline = "LONDON", group = g_snkz)
lo_txt                      = input.string("London", "", inline = "LONDON", group = g_snkz)
london                      = input.session("0200-0500", "", inline = "LONDON", group = g_snkz)
lo_color                    = input.color(#000000, "", inline = "LONDON", group = g_snkz)

use_nyam_killzone           = input.bool(true, "", inline = "NYAM", group = g_snkz)
na_txt                      = input.string("NY AM", "", inline = "NYAM", group = g_snkz)
nyam                        = input.session("0930-1100", "", inline = "NYAM", group = g_snkz)
na_color                    = input.color(#000000, "", inline = "NYAM", group = g_snkz)

use_nylu                    = input.bool(true, "", inline = "NYLU", group = g_snkz)
nl_txt                      = input.string("NY Lunch", "", inline = "NYLU", group = g_snkz)
nylu                        = input.session("1200-1300", "", inline = "NYLU", group = g_snkz)
nl_color                    = input.color(#f57f17, "", inline = "NYLU", group = g_snkz)

use_nypm_killzone           = input.bool(true, "", inline = "NYPM", group = g_snkz)
np_txt                      = input.string("NY PM", "", inline = "NYPM", group = g_snkz)
nypm                        = input.session("1330-1600", "", inline = "NYPM", group = g_snkz)
np_color                    = input.color(#000000, "", inline = "NYPM", group = g_snkz)

show_kz                     = input.bool(true, "Show Killzone Boxes", inline = "KZ", group = g_snkz)
show_kz_text                = input.bool(true, "Display Text", inline = "KZ", group = g_snkz)
show_pivots                 = input.bool(true, "Show Pivots", inline = "PV", group = g_snkz)
show_midpoints              = input.bool(true, "Show Pivots Midpoints", inline = "PV", group = g_snkz)
stop_midpoints              = input.bool(true, "Stop Once Mitigated", inline = "mp", group = g_snkz)
use_alerts                  = input.bool(true, "Alert Broken Pivots", inline = "mp", tooltip = "The desired killzones must be enabled at the time that an alert is created, along with the show pivots option, in order for alerts to work", group = g_snkz)
ext_pivots                  = input.string("Until Mitigated", "Extend Pivots...", options = ['Until Mitigated', 'Past Mitigation'], group = g_snkz)
ext_which                   = input.string("Most Recent", "...From Which Sessions", options = ['Most Recent', 'All'], group = g_snkz)

box_transparency            = input.int(94, "Box Transparency", 0, 100, group = g_snkz)
text_transparency           = input.int(98, "Text Transparency", 0, 100, group = g_snkz)
kzp_style                   = get_line_type(input.string(defval = 'Solid', title = "Pivot Style", options = ['Solid', 'Dotted', 'Dashed'], inline = "KZP", group = g_snkz))
kzp_width                   = input.int(1, "", inline = "KZP", group = g_snkz)
kzm_style                   = get_line_type(input.string(defval = 'Dotted', title = "Midpoint Style", options = ['Solid', 'Dotted', 'Dashed'], inline = "KZM", group = g_snkz))
kzm_width                   = input.int(1, "", inline = "KZM", group = g_snkz)

htf1.settings.show          := input.bool(true, 'HTF 1      ', inline = 'htf1', group = g_htfcandles)
htf_1                       = input.timeframe('30', '', inline = 'htf1', group = g_htfcandles)
htf1.settings.htf           := htf_1
htf1.settings.max_display   := input.int(24, '', inline = 'htf1', group = g_htfcandles)

htf2.settings.show          := input.bool(true, 'HTF 2      ', inline = 'htf2', group = g_htfcandles)
htf_2                       = input.timeframe('60', '', inline = 'htf2', group = g_htfcandles)
htf2.settings.htf           := htf_2
htf2.settings.max_display   := input.int(18, '', inline = 'htf2', group = g_htfcandles)

htf3.settings.show          := input.bool(true, 'HTF 3      ', inline = 'htf3', group = g_htfcandles)
htf_3                       = input.timeframe('240', '', inline = 'htf3', group = g_htfcandles)
htf3.settings.htf           := htf_3
htf3.settings.max_display   := input.int(12, '', inline = 'htf3', group = g_htfcandles)

htf4.settings.show          := input.bool(true, 'HTF 4      ', inline = 'htf4', group = g_htfcandles)
htf_4                       = input.timeframe('1D', '', inline = 'htf4', group = g_htfcandles)
htf4.settings.htf           := htf_4
htf4.settings.max_display   := input.int(6, '', inline = 'htf4', group = g_htfcandles)

htf5.settings.show          := input.bool(true, 'HTF 5      ', inline = 'htf5', group = g_htfcandles)
htf_5                       = input.timeframe('1W', '', inline = 'htf5', group = g_htfcandles)
htf5.settings.htf           := htf_5
htf5.settings.max_display   := input.int(3, '', inline = 'htf5', group = g_htfcandles)

htf6.settings.show          := input.bool(true, 'HTF 6      ', inline = 'htf6', group = g_htfcandles)
htf_6                       = input.timeframe('1M', '', inline = 'htf6', group = g_htfcandles)
htf6.settings.htf           := htf_6
htf6.settings.max_display   := input.int(2, '', inline = 'htf6', group = g_htfcandles)

settings.max_sets           := input.int(4, 'Limit to next HTFs only', minval = 1, maxval = 6, group = g_htfcandles)
settings.use_custom_daily   := input.bool(false, 'Custom daily candle open     ', inline='customdaily', group = g_htfcandles)
settings.custom_daily       := input.string('Midnight', '', options=['Midnight', '8:30', '9:30'], inline='customdaily', group = g_htfcandles)
settings.bull_body          := input.color(color.green, 'Body  ', inline = 'body', group = g_htfcandles)
settings.bear_body          := input.color(color.black, '', inline = 'body', group = g_htfcandles)
settings.bull_border        := input.color(color.black, 'Borders', inline = 'borders', group = g_htfcandles)
settings.bear_border        := input.color(color.black, '', inline = 'borders', group = g_htfcandles)
settings.bull_wick          := input.color(color.black, 'Wick  ', inline = 'wick', group = g_htfcandles)
settings.bear_wick          := input.color(color.black, '', inline = 'wick', group = g_htfcandles)

settings.offset             := input.int(20, 'padding from current candles', minval = 1, group = g_htfcandles)
settings.buffer             := input.int(1, 'space between candles', minval = 1, maxval = 4, group = g_htfcandles)
settings.htf_buffer         := input.int(10, 'space between Higher Timeframes', minval = 1, maxval = 10, group = g_htfcandles)
settings.width              := input.int(1, 'Candle Width', minval = 1, maxval = 4, group = g_htfcandles) * 2

settings.htf_label_show     := input.bool(true, 'HTF Label           ', group = g_label, inline = 'HTFlabel')
settings.htf_label_color    := input.color(color.new(color.black, 10), '', group = g_label, inline = 'HTFlabel')
settings.htf_label_size     := input.string(size.normal, '', [size.tiny, size.small, size.normal, size.large, size.huge], group = g_label, inline = 'HTFlabel')

settings.label_position     := input.string("Both", 'Label Positions', options=['Both', 'Top', 'Bottom'], group = g_label)
settings.label_alignment    := input.string("Follow Candles", "Label Alignment", options=['Align', 'Follow Candles'], group = g_label)

settings.htf_timer_show     := input.bool(true, 'Remaining time      ', inline = 'timer', group = g_label)
settings.htf_timer_color    := input.color(color.new(color.black, 10), '', inline = 'timer', group = g_label)
settings.htf_timer_size     := input.string(size.normal, '', [size.tiny, size.small, size.normal, size.large, size.huge], group = g_label, inline = 'timer')

settings.daily_name         := input.bool(true, 'Interval Value        ', group = g_label, inline = 'dow')
settings.dow_color          := input.color(color.black , '', group = g_label, inline = 'dow')
settings.dow_size           := input.string(size.tiny, '', [size.tiny, size.small, size.normal, size.large, size.huge], group = g_label, inline = 'dow')

settings.fvg_show           := input.bool(true, 'Fair Value Gap   ', group = g_imbalance, inline = 'fvg')
settings.fvg_color          := input.color(color.new(color.gray, 80), '', inline = 'fvg', group = g_imbalance)

settings.vi_show            := input.bool(true, 'Volume Imbalance', group = g_imbalance, inline = 'vi')
settings.vi_color           := input.color(color.new(color.red, 50), '', inline = 'vi', group = g_imbalance)

settings.trace_show         := input.bool(false, 'Trace lines', group = g_trace)
settings.trace_o_color      := input.color(color.new(color.gray, 50), 'Open    ', inline = '1', group = g_trace)
settings.trace_o_style      := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '1', group = g_trace)
settings.trace_o_size       := input.int(1, '', options = [1, 2, 3, 4], inline = '1', group = g_trace)
settings.trace_c_color      := input.color(color.new(color.gray, 50), 'Close    ', inline = '2', group = g_trace)
settings.trace_c_style      := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '2', group = g_trace)
settings.trace_c_size       := input.int(1, '', options = [1, 2, 3, 4], inline = '2', group = g_trace)
settings.trace_h_color      := input.color(color.new(color.gray, 50), 'High     ', inline = '3', group = g_trace)
settings.trace_h_style      := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '3', group = g_trace)
settings.trace_h_size       := input.int(1, '', options = [1, 2, 3, 4], inline = '3', group = g_trace)
settings.trace_l_color      := input.color(color.new(color.gray, 50), 'Low     ', inline = '4', group = g_trace)
settings.trace_l_style      := input.string('····', '', options = ['⎯⎯⎯', '----', '····'], inline = '4', group = g_trace)
settings.trace_l_size       := input.int(1, '', options = [1, 2, 3, 4], inline = '4', group = g_trace)
settings.trace_anchor       := input.string('First Timeframe', 'Anchor to', options = ['First Timeframe', 'Last Timeframe'], group = g_trace)

settings.label_show         := input.bool(false, 'Price Label           ', inline = 'label')
settings.label_color        := input.color(color.new(color.black, 10), '', inline = 'label')
settings.label_size         := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline = 'label')

alert_HL                    = input.bool(true, "Alert High/Low Break", tooltip = "Alert when any selected highs and lows are traded through. The desired timeframe's high/low option must be enabled at the time that an alert is created", group = g_dwm)

show_d_open                 = input.bool(false, "D Open", inline = "DO", group = g_dwm)
dhl                         = input.bool(true, "High/Low", inline = "DO", tooltip = "", group = g_dwm)
ds                          = input.bool(false, "Separators", inline = "DO", tooltip = "Mark where a new day begins", group = g_dwm)
tf_limit_daily              = input.timeframe("240", "", inline = "DO", tooltip = "Drawings will not appear on timeframes greater than or equal to this", group = g_dwm)
d_color                     = input.color(color.red, "", inline = "DO", group = g_dwm)

show_w_open                 = input.bool(false, "W Open", inline = "WO", group = g_dwm)
whl                         = input.bool(true, "High/Low", inline = "WO", tooltip = "", group = g_dwm)
ws                          = input.bool(false, "Separators", inline = "WO", tooltip = "Mark where a new week begins", group = g_dwm)
tf_limit_weekly             = input.timeframe("D", "", inline = "WO", tooltip = "Drawings will not appear on timeframes greater than or equal to this", group = g_dwm)
w_color                     = input.color(color.red, "", inline = "WO", group = g_dwm)

show_m_open                 = input.bool(false, "M Open", inline = "MO", group = g_dwm)
mhl                         = input.bool(true, "High/Low", inline = "MO", tooltip = "", group = g_dwm)
ms                          = input.bool(false, "Separators", inline = "MO", tooltip = "Mark where a new month begins", group = g_dwm)
tf_limit_monthly            = input.timeframe("W", "", inline = "MO", tooltip = "Drawings will not appear on timeframes greater than or equal to this", group = g_dwm)
m_color                     = input.color(color.red, "", inline = "MO", group = g_dwm)

htf_style                   = get_line_type(input.string(defval = 'Solid', title = "Style", options = ['Solid', 'Dotted', 'Dashed'], inline = "D0", group = g_dwm))
htf_width                   = input.int(1, "", inline = "D0", group = g_dwm)

use_ma1                     = input.bool(true, "MA 1", inline="MA1", group = g_ma)
type_ma1                    = input.string("EMA", "", options=["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"], inline="MA1", group = g_ma)
source_ma1                  = input.string("close", "", options=["open", "high", "low", "close", "hl2", "hlc3", "ohlc4", "hlcc4"], inline="MA1", group = g_ma)
length_ma1                  = input.int(5, "", inline="MA1", group = g_ma)
color_ma1                   = input.color(color.blue, "", inline="MA1", group = g_ma)

use_ma2                     = input.bool(true, "MA 2", inline="MA2", group = g_ma)
type_ma2                    = input.string("EMA", "", options=["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"], inline="MA2", group = g_ma)
source_ma2                  = input.string("close", "", options=["open", "high", "low", "close", "hl2", "hlc3", "ohlc4", "hlcc4"], inline="MA2", group = g_ma)
length_ma2                  = input.int(50, "", inline="MA2", group = g_ma)
color_ma2                   = input.color(color.black, "", inline="MA2", group = g_ma)

use_ma3                     = input.bool(false, "MA 3", inline="MA3", group = g_ma)
type_ma3                    = input.string("EMA", "", options=["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"], inline="MA3", group = g_ma)
source_ma3                  = input.string("close", "", options=["open", "high", "low", "close", "hl2", "hlc3", "ohlc4", "hlcc4"], inline="MA3", group = g_ma)
length_ma3                  = input.int(100, "", inline="MA3", group = g_ma)
color_ma3                   = input.color(color.green, "", inline="MA3", group = g_ma)

use_ma4                     = input.bool(true, "MA 4", inline="MA4", group = g_ma)
type_ma4                    = input.string("EMA", "", options=["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"], inline="MA4", group = g_ma)
source_ma4                  = input.string("close", "", options=["open", "high", "low", "close", "hl2", "hlc3", "ohlc4", "hlcc4"], inline="MA4", group = g_ma)
length_ma4                  = input.int(200, "", inline="MA4", group = g_ma)
color_ma4                   = input.color(color.red, "", inline="MA4", group = g_ma)

use_h1                      = input.bool(true, "", inline = "H1", group = g_extraoptions)
h1_text                     = input.string("True Day Open", "", inline = "H1", group = g_extraoptions)
h1                          = input.session("0000-0001", "", inline = "H1", group = g_extraoptions)
h1_color                    = input.color(color.black, "", inline = "H1", group = g_extraoptions)

use_h2                      = input.bool(false, "", inline = "H2", group = g_extraoptions)
h2_text                     = input.string("", "", inline = "H2", group = g_extraoptions)
h2                          = input.session("0600-0601", "", inline = "H2", group = g_extraoptions)
h2_color                    = input.color(color.black, "", inline = "H2", group = g_extraoptions)

hz_style                    = get_line_type(input.string(defval = 'Dotted', title = "Horizontal Line Style", options = ['Solid', 'Dotted', 'Dashed'], inline = "H0", group = g_extraoptions))
hz_width                    = input.int(1, "", inline = "H0", group = g_extraoptions)

var as_s = kz.new(as_txt, array.new_box(), array.new_line(), array.new_line(), array.new_line(), array.new_bool(), array.new_bool(), array.new_bool())
var ls_s = kz.new(ls_txt, array.new_box(), array.new_line(), array.new_line(), array.new_line(), array.new_bool(), array.new_bool(), array.new_bool())
var nys_s = kz.new(nys_txt, array.new_box(), array.new_line(), array.new_line(), array.new_line(), array.new_bool(), array.new_bool(), array.new_bool())

var as_kz = kz.new(ak_txt, array.new_box(), array.new_line(), array.new_line(), array.new_line(), array.new_bool(), array.new_bool(), array.new_bool())
var lo_kz = kz.new(lo_txt, array.new_box(), array.new_line(), array.new_line(), array.new_line(), array.new_bool(), array.new_bool(), array.new_bool())
var na_kz = kz.new(na_txt, array.new_box(), array.new_line(), array.new_line(), array.new_line(), array.new_bool(), array.new_bool(), array.new_bool())
var nl_kz = kz.new(nl_txt, array.new_box(), array.new_line(), array.new_line(), array.new_line(), array.new_bool(), array.new_bool(), array.new_bool())
var np_kz = kz.new(np_txt, array.new_box(), array.new_line(), array.new_line(), array.new_line(), array.new_bool(), array.new_bool(), array.new_bool())

t_as = not na(time("", asian_session, gmt_tz))
t_ls = not na(time("", london_session, gmt_tz))
t_ns = not na(time("", newyork_session, gmt_tz))
t_ak = not na(time("", asia, gmt_tz))
t_lo = not na(time("", london, gmt_tz))
t_na = not na(time("", nyam, gmt_tz))
t_nl = not na(time("", nylu, gmt_tz))
t_np = not na(time("", nypm, gmt_tz))
t_co = not na(time("", cutoff, gmt_tz))

t_h1 = not na(time("", h1, gmt_tz))
t_h2 = not na(time("", h2, gmt_tz))

var ext_current = ext_which == 'Most Recent'
var ext_past = ext_pivots == 'Past Mitigation'
var transparent = #ffffff00

Helper helper = Helper.new()
var Trace trace = Trace.new()
color color_transparent = #ffffff00

// ---------------------------------------- Functions --------------------------------------------------

get_box_color(color c) =>
    color.new(c, box_transparency)

get_text_color(color c) =>
    color.new(c, text_transparency)

get_source(source) =>
    switch source
        "open" => open
        "high" => high
        "low" => low
        "close" => close
        "hl2" => hl2
        "hlc3" => hlc3
        "ohlc4" => ohlc4
        "hlcc4" => hlcc4

update_dwm_info(dwm_info n) =>
    if timeframe.change(n.tf)
        n.ph := n.h
        n.pl := n.l
        n.o := open
        n.h := high
        n.l := low
    else
        n.h := math.max(high, n.h)
        n.l := math.min(low, n.l)

get_ma(type, source, length) =>
    type == 'SMA' ? ta.sma(source, length) : type == 'EMA' ? ta.ema(source, length) : type == 'SMMA (RMA)' ? ta.rma(source, length) : type == 'WMA' ? ta.wma(source, length) : ta.vwma(source, length)

if dhl or show_d_open
    update_dwm_info(d_info)
if whl or show_w_open
    update_dwm_info(w_info)
if mhl or show_m_open
    update_dwm_info(m_info)

method LineStyle(Helper helper, string style) =>
    helper.name := style
    out = switch style
        '----' => line.style_dashed
        '····' => line.style_dotted
        => line.style_solid
    out

method DayofWeek(Helper helper, int index) =>
    helper.name := 'DOW'
    switch
        index == 1 => 'M'
        index == 2 => 'T'
        index == 3 => 'W'
        index == 4 => 'T'
        index == 5 => 'F'
        index == 6 => 'S'
        index == 7 => 'S'
        na(index) => ''

method ValidTimeframe(Helper helper, string HTF) =>
    helper.name := HTF
    if timeframe.in_seconds(HTF) >= timeframe.in_seconds('D') and timeframe.in_seconds(HTF) > timeframe.in_seconds()
        true
    else
        n1 = timeframe.in_seconds()
        n2 = timeframe.in_seconds(HTF)
        n3 = n1 % n2
        n1 < n2 and math.round(n2 / n1) == n2 / n1


method RemainingTime(Helper helper, string HTF) =>
    helper.name := HTF
    if barstate.isrealtime
        timeRemaining = (time_close(HTF) - timenow) / 1000
        days = math.floor(timeRemaining / 86400)
        hours = math.floor((timeRemaining - days * 86400) / 3600)
        minutes = math.floor((timeRemaining - days * 86400 - hours * 3600) / 60)
        seconds = math.floor(timeRemaining - days * 86400 - hours * 3600 - minutes * 60)

        r = str.tostring(seconds, '00')
        if minutes > 0 or hours > 0 or days > 0
            r := str.tostring(minutes, '00') + ':' + r
            r
        if hours > 0 or days > 0
            r := str.tostring(hours, '00') + ':' + r
            r
        if days > 0
            r := str.tostring(days) + 'D ' + r
            r
        r
    else
        'n/a'

method HTFName(Helper helper, string HTF) =>
    helper.name := 'HTFName'
    formatted = HTF

    seconds = timeframe.in_seconds(HTF)
    if seconds < 60
        formatted := str.tostring(seconds) + 's'
        formatted
    else if seconds / 60 < 60
        formatted := str.tostring(seconds / 60) + 'm'
        formatted
    else if seconds / 60 / 60 < 24
        formatted := str.tostring(seconds / 60 / 60) + 'H'
        formatted
    formatted

method HTFEnabled(Helper helper) =>
    helper.name := 'HTFEnabled'
    int enabled = 0
    enabled := enabled + (htf1.settings.show ? 1 : 0)
    enabled := enabled + (htf2.settings.show ? 1 : 0)
    enabled := enabled + (htf3.settings.show ? 1 : 0)
    enabled := enabled + (htf4.settings.show ? 1 : 0)
    enabled := enabled + (htf5.settings.show ? 1 : 0)
    enabled := enabled + (htf6.settings.show ? 1 : 0)
    int last = math.min(enabled, settings.max_sets)

    last

// ---------------------------------------- Functions --------------------------------------------------

// ---------------------------------------- Core Logic --------------------------------------------------

dwm_sep(string tf, bool use, line[] arr, color col) =>
    if use and timeframe.change(tf)
        arr.unshift(line.new(bar_index, high * 1.0001, bar_index, low, style = htf_style, width = htf_width, extend = extend.both, color = col))
        if arr.size() > max_days
            arr.pop().delete()

dwm_open(string tf, bool use, line[] lns, label[] lbls, dwm_info n, color col, string tf_limit) =>
    if use and timeframe.in_seconds("") <= timeframe.in_seconds(tf_limit)
        if lns.size() > 0
            lns.get(0).set_x2(time)
            lbls.get(0).set_x(time)
        if timeframe.change(tf)
            lns.unshift(line.new(time, n.o, time, n.o, xloc = xloc.bar_time, style = htf_style, width = htf_width, color = col))
            lbls.unshift(label.new(time, n.o, tf + " OPEN", xloc = xloc.bar_time, style = label.style_label_left, color = transparent, textcolor = txt_color, size = lbl_size))
            if lns.size() > max_days
                lns.pop().delete()
                lbls.pop().delete()

dwm_hl(string tf, bool use, dwm_hl hl, dwm_info n, color col, string tf_limit) =>
    if use and timeframe.in_seconds("") <= timeframe.in_seconds(tf_limit)
        if hl.hi_line.size() > 0
            hl.hi_line.get(0).set_x2(time)
            hl.lo_line.get(0).set_x2(time)
            hl.hi_label.get(0).set_x(time)
            hl.lo_label.get(0).set_x(time)
        if timeframe.change(tf)
            if hl.hi_line.size() > 0
                hl.hi_line.get(0).delete()
                hl.lo_line.get(0).delete()
                hl.hi_label.get(0).delete()
                hl.lo_label.get(0).delete()
            hl.hi_line.unshift(line.new(time, n.ph, time, n.ph, xloc = xloc.bar_time, style = htf_style, width = htf_width, color = col))
            hl.lo_line.unshift(line.new(time, n.pl, time, n.pl, xloc = xloc.bar_time, style = htf_style, width = htf_width, color = col))
            hl.hi_label.unshift(label.new(time, n.ph, "P" + tf + "H", xloc = xloc.bar_time, style = label.style_label_left, color = transparent, textcolor = txt_color, size = lbl_size))
            hl.lo_label.unshift(label.new(time, n.pl, "P" + tf + "L", xloc = xloc.bar_time, style = label.style_label_left, color = transparent, textcolor = txt_color, size = lbl_size))
            hl.hit_high := false
            hl.hit_low := false
            if hl.hi_line.size() > max_days
                hl.hi_line.pop().delete()
                hl.lo_line.pop().delete()
                hl.hi_label.pop().delete()
                hl.lo_label.pop().delete()
        if hl.hi_line.size() > 0 and alert_HL
            if not hl.hit_high and high > hl.hi_line.get(0).get_y1()
                hl.hit_high := true
                alert(str.format("Hit P{0}H", tf))
            if not hl.hit_low and low < hl.lo_line.get(0).get_y1()
                hl.hit_low := true
                alert(str.format("Hit P{0}L", tf))

dwm() =>
    // DWM - Open Lines
    dwm_open("D", show_d_open, d_line, d_label, d_info, d_color, tf_limit_daily)
    dwm_open("W", show_w_open, w_line, w_label, w_info, w_color, tf_limit_weekly)
    dwm_open("M", show_m_open, m_line, m_label, m_info, m_color, tf_limit_monthly)

    // DWM - Highs and Lows
    dwm_hl("D", dhl, d_hl, d_info, d_color, tf_limit_daily)
    dwm_hl("W", whl, w_hl, w_info, w_color, tf_limit_weekly)
    dwm_hl("M", mhl, m_hl, m_info, m_color, tf_limit_monthly)

hz_line(bool use, bool t, hz hz, string txt, color col) =>
    if use and timeframe.in_seconds("") <= timeframe.in_seconds(tf_limit)
        if t and not t[1]
            hz.LN.unshift(line.new(bar_index, open, bar_index, open, style = hz_style, width = hz_width, color = col))
            hz.LB.unshift(label.new(bar_index, open, txt, style = label.style_label_left, color = transparent, textcolor = txt_color, size = lbl_size))
            array.unshift(hz.CO, false)
            if hz.LN.size() > max_days
                hz.LN.pop().delete()
                hz.LB.pop().delete()
                hz.CO.pop()
        if not t and hz.CO.size() > 0
            if not hz.CO.get(0)
                hz.LN.get(0).set_x2(bar_index)
                hz.LB.get(0).set_x(bar_index)
                if (use_cutoff ? t_co : false)
                    hz.CO.set(0, true)

del_kz(kz k) =>
    if k._box.size() > max_days
        k._box.pop().delete()
    if k._hi_line.size() > max_days
        k._hi_line.pop().delete()
        k._lo_line.pop().delete()
        k._hi_valid.pop()
        k._lo_valid.pop()
        if show_midpoints
            k._md_line.pop().delete()
            k._md_valid.pop()

adjust_in_kz(kz kz, bool t) =>
    if t
        kz._box.get(0).set_right(time)
        kz._box.get(0).set_top(math.max(kz._box.get(0).get_top(), high))
        kz._box.get(0).set_bottom(math.min(kz._box.get(0).get_bottom(), low))

        if show_pivots and kz._hi_line.size() > 0
            kz._hi_line.get(0).set_x2(time)
            if high > kz._hi_line.get(0).get_y1()
                kz._hi_line.get(0).set_xy1(time, high)
                kz._hi_line.get(0).set_xy2(time, high)

            kz._lo_line.get(0).set_x2(time)
            if low < kz._lo_line.get(0).get_y1()
                kz._lo_line.get(0).set_xy1(time, low)
                kz._lo_line.get(0).set_xy2(time, low)

            if show_midpoints
                kz._md_line.get(0).set_x2(time)
                kz._md_line.get(0).set_xy1(time, math.avg(kz._hi_line.get(0).get_y2(), kz._lo_line.get(0).get_y2()))
                kz._md_line.get(0).set_xy2(time, math.avg(kz._hi_line.get(0).get_y2(), kz._lo_line.get(0).get_y2()))

adjust_out_kz(kz kz, bool t) =>
    if kz._box.size() > 0 and show_pivots
        for i = 0 to kz._box.size() - 1
            if not ext_current or (ext_current and i == 0)
                if ext_past or kz._hi_valid.get(i)
                    kz._hi_line.get(i).set_x2(time)
                if high > kz._hi_line.get(i).get_y1() and kz._hi_valid.get(i)
                    if use_alerts and i == 0
                        alert("Broke " + kz._title + " High", alert.freq_once_per_bar)
                    kz._hi_valid.set(i, false)
                else if use_cutoff and t_co
                    kz._hi_valid.set(i, false)

                if ext_past or kz._lo_valid.get(i)
                    kz._lo_line.get(i).set_x2(time)
                if low < kz._lo_line.get(i).get_y1() and kz._lo_valid.get(i)
                    if use_alerts and i == 0
                        alert("Broke " + kz._title + " Low", alert.freq_once_per_bar)
                    kz._lo_valid.set(i, false)
                else if use_cutoff and t_co
                    kz._lo_valid.set(i, false)

                if show_midpoints and not t
                    if stop_midpoints ? kz._md_valid.get(i) : true
                        kz._md_line.get(i).set_x2(time)
                        if kz._md_valid.get(i) and low <= kz._md_line.get(i).get_y1() and high >= kz._md_line.get(i).get_y1()
                            kz._md_valid.set(i, false)
            else
                break

manage_kz(kz kz, bool use, bool t, color c, string box_txt) =>
    if timeframe.in_seconds("") <= timeframe.in_seconds(tf_limit) and use
        if t and not t[1]
            _c = get_box_color(c)
            _t = get_text_color(c)
            kz._box.unshift(box.new(time, high, time, low, xloc = xloc.bar_time, border_color = show_kz ? _c : na, bgcolor = show_kz ? _c : na, text = (show_kz and show_kz_text) ? box_txt : na, text_color = _t))

            if show_pivots
                kz._hi_line.unshift(line.new(time, high, time, high, xloc = xloc.bar_time, style = kzp_style, color = c, width = kzp_width))
                kz._lo_line.unshift(line.new(time, low, time, low, xloc = xloc.bar_time, style = kzp_style, color = c, width = kzp_width))
                if show_midpoints
                    kz._md_line.unshift(line.new(time, math.avg(high, low), time, math.avg(high, low), xloc = xloc.bar_time, style = kzm_style, color = c, width = kzm_width))
                    array.unshift(kz._md_valid, true)

                array.unshift(kz._hi_valid, true)
                array.unshift(kz._lo_valid, true)
            
            del_kz(kz)
        adjust_in_kz(kz, t)
        adjust_out_kz(kz, t)

method CandleSetHigh(Helper helper, array<Candle> candles, float h) =>
    helper.name := 'CandlesSetHigh'
    float _h = h
    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.h > _h
                _h := c.h
                _h
    _h

method CandleSetLow(Helper helper, array<Candle> candles, float l) =>
    helper.name := 'CandlesSetLow'
    float _l = l
    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.l < _l
                _l := c.l
                _l
    _l

method CandlesHigh(Helper helper, array<Candle> candles) =>
    helper.name := 'CandlesHigh'
    h = 0.0
    int cnt = 0
    int last = helper.HTFEnabled()

    if htf1.settings.show and helper.ValidTimeframe(htf1.settings.htf)
        h := helper.CandleSetHigh(htf1.candles, h)
        cnt := cnt + 1
    if htf2.settings.show and helper.ValidTimeframe(htf2.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf2.candles, h)
        cnt := cnt + 1
    if htf3.settings.show and helper.ValidTimeframe(htf3.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf3.candles, h)
        cnt := cnt + 1
    if htf4.settings.show and helper.ValidTimeframe(htf4.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf4.candles, h)
        cnt := cnt + 1
    if htf5.settings.show and helper.ValidTimeframe(htf5.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf5.candles, h)
        cnt := cnt + 1
    if htf6.settings.show and helper.ValidTimeframe(htf6.settings.htf) and cnt < last
        h := helper.CandleSetHigh(htf6.candles, h)

    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.h > h
                h := c.h
    h

method CandlesLow(Helper helper, array<Candle> candles, float h) =>
    helper.name := 'CandlesLow'
    l = h
    int cnt = 0
    int last = helper.HTFEnabled()

    if htf1.settings.show and helper.ValidTimeframe(htf1.settings.htf)
        l := helper.CandleSetLow(htf1.candles, l)
        cnt := cnt + 1
    if htf2.settings.show and helper.ValidTimeframe(htf2.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf2.candles, l)
        cnt := cnt + 1
    if htf3.settings.show and helper.ValidTimeframe(htf3.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf3.candles, l)
        cnt := cnt + 1
    if htf4.settings.show and helper.ValidTimeframe(htf4.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf4.candles, l)
        cnt := cnt + 1
    if htf5.settings.show and helper.ValidTimeframe(htf5.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf5.candles, l)
        cnt := cnt + 1
    if htf6.settings.show and helper.ValidTimeframe(htf6.settings.htf) and cnt < last
        l := helper.CandleSetLow(htf6.candles, l)

    if array.size(candles) > 0
        for i = 0 to array.size(candles) - 1 by 1
            Candle c = array.get(candles, i)
            if c.l < l
                l := c.l
    l

method UpdateTime(CandleSet candleSet, int offset) =>
    if settings.htf_timer_show and (barstate.isrealtime or barstate.islast)
        string tmr = '(' + helper.RemainingTime(candleSet.settings.htf) + ')'

        if not na(candleSet.tfTimerTop)
            candleSet.tfTimerTop.set_text(tmr)

        if not na(candleSet.tfTimerBottom)
            candleSet.tfTimerBottom.set_text(tmr)
    candleSet

method Reorder(CandleSet candleSet, int offset) =>
    size = candleSet.candles.size()

    if size > 0
        for i = size - 1 to 0 by 1
            Candle candle = candleSet.candles.get(i)
            t_buffer = offset + (settings.width + settings.buffer) * (size - i - 1)
            box.set_left(candle.body, bar_index + t_buffer)
            box.set_right(candle.body, bar_index + settings.width + t_buffer)
            line.set_x1(candle.wick_up, bar_index + settings.width / 2 + t_buffer)
            line.set_x2(candle.wick_up, bar_index + settings.width / 2 + t_buffer)
            line.set_x1(candle.wick_down, bar_index + settings.width / 2 + t_buffer)
            line.set_x2(candle.wick_down, bar_index + settings.width / 2 + t_buffer)

            if settings.daily_name //and candleSet.settings.htf == '1D'
                if not na(candle.dow_label)
                    candle.dow_label.set_y(candle.h)
                    candle.dow_label.set_x(bar_index + settings.width / 2 + t_buffer)
                    candle.dow_label.set_text(candle.dow)
                else
                    candle.dow_label := label.new(bar_index + settings.width / 2 + t_buffer, candle.h, candle.dow, color = color_transparent, textcolor = settings.dow_color, style = label.style_label_down, size = settings.dow_size)

    top = 0.0
    bottom = 0.0

    if settings.label_alignment == 'Align'
        top := helper.CandlesHigh(candleSet.candles)
        bottom := helper.CandlesLow(candleSet.candles, top)
    if settings.label_alignment == 'Follow Candles'
        top := helper.CandleSetHigh(candleSet.candles, 0)
        bottom := helper.CandleSetLow(candleSet.candles, top)

    left = bar_index + offset + (settings.width + settings.buffer) * (size - 1) / 2

    if settings.htf_label_show
        string lblt = helper.HTFName(candleSet.settings.htf)
        string lbll = lblt
        if settings.htf_timer_show
            lblt := lblt + '\n'
            lbll := '\n' + lbll
        if settings.daily_name
            lblt := lblt + '\n'

        string tmr = '(' + helper.RemainingTime(candleSet.settings.htf) + ')' + (settings.daily_name ? '\n' : '')
        if settings.label_position == 'Both' or settings.label_position == 'Top'
            
            if not na(candleSet.tfNameTop)
                candleSet.tfNameTop.set_xy(left, top)
            else
                candleSet.tfNameTop := label.new(left, top, lblt, color = color_transparent, textcolor = settings.htf_label_color, style = label.style_label_down, size = settings.htf_label_size)
            if settings.htf_timer_show
                if not na(candleSet.tfTimerTop)
                    candleSet.tfTimerTop.set_xy(left, top)
                else
                    candleSet.tfTimerTop := label.new(left, top, tmr, color = color_transparent, textcolor = settings.htf_timer_color, style = label.style_label_down, size = settings.htf_timer_size)

        if settings.label_position == 'Both' or settings.label_position == 'Bottom'
            if not na(candleSet.tfNameBottom)
                candleSet.tfNameBottom.set_xy(left, bottom)
            else
                candleSet.tfNameBottom := label.new(left, bottom, lbll, color = color_transparent, textcolor = settings.htf_label_color, style = label.style_label_up, size = settings.htf_label_size)
            if settings.htf_timer_show
                if settings.htf_timer_show
                    if not na(candleSet.tfTimerBottom)
                        candleSet.tfTimerBottom.set_xy(left, bottom)
                    else
                        candleSet.tfTimerBottom := label.new(left, bottom, tmr, color = color_transparent, textcolor = settings.htf_timer_color, style = label.style_label_up, size = settings.htf_timer_size)

    candleSet

method FindImbalance(CandleSet candleSet) =>
    if barstate.isrealtime or barstate.islast
        if candleSet.imbalances.size() > 0
            for i = candleSet.imbalances.size() - 1 to 0 by 1
                Imbalance del = candleSet.imbalances.get(i)
                box.delete(del.b)
                candleSet.imbalances.pop()

        if candleSet.candles.size() > 3 and settings.fvg_show
            for i = 0 to candleSet.candles.size() - 3 by 1
                candle1 = candleSet.candles.get(i)
                candle2 = candleSet.candles.get(i + 2)
                candle3 = candleSet.candles.get(i + 1)

                if candle1.l > candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
                    Imbalance imb = Imbalance.new()
                    imb.b := box.new(box.get_left(candle2.body), candle2.h, box.get_right(candle1.body), candle1.l, bgcolor = settings.fvg_color, border_color = color_transparent, xloc = xloc.bar_index)
                    candleSet.imbalances.push(imb)
                if candle1.h < candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
                    Imbalance imb = Imbalance.new()
                    imb.b := box.new(box.get_right(candle1.body), candle1.h, box.get_left(candle2.body), candle2.l, bgcolor = settings.fvg_color, border_color = color_transparent)
                    candleSet.imbalances.push(imb)
                box temp = box.copy(candle3.body)
                box.delete(candle3.body)
                candle3.body := temp
                candle3.body

        if candleSet.candles.size() > 2 and settings.vi_show
            for i = 0 to candleSet.candles.size() - 2 by 1
                candle1 = candleSet.candles.get(i)
                candle2 = candleSet.candles.get(i + 1)
                if candle1.l < candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
                    Imbalance imb = Imbalance.new()
                    imb.b := box.new(box.get_left(candle2.body), math.min(candle1.o, candle1.c), box.get_right(candle1.body), math.max(candle2.o, candle2.c), bgcolor = settings.vi_color, border_color = color_transparent)
                    candleSet.imbalances.push(imb)
                if candle1.h > candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
                    Imbalance imb = Imbalance.new()
                    imb.b := box.new(box.get_right(candle1.body), math.min(candle2.o, candle2.c), box.get_left(candle2.body), math.max(candle1.o, candle1.c), bgcolor = settings.vi_color, border_color = color_transparent)
                    candleSet.imbalances.push(imb)
    candleSet

method Monitor(CandleSet candleSet) =>
    HTFBarTime = time(candleSet.settings.htf, 'america/New_York')
    isNewHTFCandle = ta.change(HTFBarTime) > 0

    if settings.use_custom_daily
        int _830 = 0
        if isNewHTFCandle
            _830 := timestamp("America/New_York", year(time), month(time), dayofmonth(time), 0, 0) + 30600000
        if candleSet.settings.htf == '1D'
            if settings.custom_daily == 'Midnight'
                isNewHTFCandle := dayofweek(time, 'America/New_York') != dayofweek(time - (time - time[1]), 'America/New_York')
            if settings.custom_daily == '8:30'    
                // Get 8:30 AM New York time for today 
                isNewHTFCandle := not na(time(timeframe.period, "0830-0831:123456", 'America/New_York')) and na(time(timeframe.period, "0830-0831:123456", 'America/New_York')[1])
            if settings.custom_daily == '9:30'    
                // Get 9:30 AM New York time for today 
                isNewHTFCandle := not na(time(timeframe.period, "0930-0931:123456", 'America/New_York')) and na(time(timeframe.period, "0930-0931:123456", 'America/New_York')[1])
    if isNewHTFCandle
        Candle candle = Candle.new()
        candle.o := open
        candle.c := close
        candle.h := high
        candle.l := low
        candle.o_time := time
        candle.o_idx := bar_index
        candle.c_idx := bar_index
        candle.h_idx := bar_index
        candle.l_idx := bar_index
        candle.dow := switch
            candleSet.settings.htf == '1D' =>
                helper.DayofWeek(dayofweek(time_tradingday, "America/New_York"))
            str.tonumber(candleSet.settings.htf) < 60 =>
                str.format_time(candle.o_time, 'm', 'America/New_York')
            str.tonumber(candleSet.settings.htf) >= 60 =>
                str.format_time(candle.o_time, 'H', 'America/New_York')
            candleSet.settings.htf == '1M' =>
                str.format_time(candle.o_time, 'M', 'America/New_York')
            =>
                ''
        log.info('dow: {1} |{0}|', candle.dow, candleSet.settings.htf)
        bull = candle.c > candle.o

        candle.body := box.new(bar_index, math.max(candle.o, candle.c), bar_index + 2, math.min(candle.o, candle.c), bull ? settings.bull_border : settings.bear_border, 1, bgcolor = bull ? settings.bull_body : settings.bear_body)
        candle.wick_up := line.new(bar_index + 1, candle.h, bar_index, math.max(candle.o, candle.c), color = bull ? settings.bull_wick : settings.bear_wick)
        candle.wick_down := line.new(bar_index + 1, math.min(candle.o, candle.c), bar_index, candle.l, color = bull ? settings.bull_wick : settings.bear_wick)

        candleSet.candles.unshift(candle)

        if candleSet.candles.size() > candleSet.settings.max_display
            Candle delCandle = array.pop(candleSet.candles)
            box.delete(delCandle.body)
            line.delete(delCandle.wick_up)
            line.delete(delCandle.wick_down)
            delCandle.dow_label.delete()

    candleSet

method Update(CandleSet candleSet, int offset, bool showTrace) =>
    if candleSet.candles.size() > 0
        Candle candle = candleSet.candles.first()
        candle.h_idx := high > candle.h ? bar_index : candle.h_idx
        candle.h := high > candle.h ? high : candle.h
        candle.l_idx := low < candle.l ? bar_index : candle.l_idx
        candle.l := low < candle.l ? low : candle.l
        candle.c := close
        candle.c_idx := bar_index

        bull = candle.c > candle.o

        box.set_top(candle.body, candle.o)
        box.set_bottom(candle.body, candle.c)
        box.set_bgcolor(candle.body, bull ? settings.bull_body : settings.bear_body)
        box.set_border_color(candle.body, bull ? settings.bull_border : settings.bear_border)
        line.set_color(candle.wick_up, bull ? settings.bull_wick : settings.bear_wick)
        line.set_color(candle.wick_down, bull ? settings.bull_wick : settings.bear_wick)
        line.set_y1(candle.wick_up, candle.h)
        line.set_y2(candle.wick_up, math.max(candle.o, candle.c))
        line.set_y1(candle.wick_down, candle.l)
        line.set_y2(candle.wick_down, math.min(candle.o, candle.c))

        if barstate.isrealtime or barstate.islast
            candleSet.Reorder(offset)
            if settings.trace_show and showTrace
                if bar_index - candle.o_idx < 5000
                    if na(trace.o)
                        trace.o := line.new(candle.o_idx, candle.o, box.get_left(candle.body), candle.o, xloc = xloc.bar_index, color = settings.trace_o_color, style = helper.LineStyle(settings.trace_o_style), width = settings.trace_o_size)
                        trace.o
                    else
                        line.set_xy1(trace.o, candle.o_idx, candle.o)
                        line.set_xy2(trace.o, box.get_left(candle.body), candle.o)

                    if settings.label_show
                        if na(trace.o_l)
                            trace.o_l := label.new(box.get_right(candle.body), candle.o, str.tostring(candle.o), textalign = text.align_center, style = label.style_label_left, size = settings.label_size, color = color_transparent, textcolor = settings.label_color)
                            trace.o_l
                        else
                            label.set_xy(trace.o_l, box.get_right(candle.body), candle.o)
                            label.set_text(trace.o_l, str.tostring(candle.o))

                if bar_index - candle.c_idx < 5000
                    if na(trace.c)
                        trace.c := line.new(candle.c_idx, candle.c, box.get_left(candle.body), candle.c, xloc = xloc.bar_index, color = settings.trace_c_color, style = helper.LineStyle(settings.trace_c_style), width = settings.trace_c_size)
                        trace.c
                    else
                        line.set_xy1(trace.c, candle.c_idx, candle.c)
                        line.set_xy2(trace.c, box.get_left(candle.body), candle.c)

                    if settings.label_show
                        if na(trace.c_l)
                            trace.c_l := label.new(box.get_right(candle.body), candle.c, str.tostring(candle.c), textalign = text.align_center, style = label.style_label_left, size = settings.label_size, color = color_transparent, textcolor = settings.label_color)
                            trace.c_l
                        else
                            label.set_xy(trace.c_l, box.get_right(candle.body), candle.c)
                            label.set_text(trace.c_l, str.tostring(candle.c))

                if bar_index - candle.h_idx < 5000
                    if na(trace.h)
                        trace.h := line.new(candle.h_idx, candle.h, line.get_x1(candle.wick_up), candle.h, xloc = xloc.bar_index, color = settings.trace_h_color, style = helper.LineStyle(settings.trace_h_style), width = settings.trace_h_size)
                        trace.h
                    else
                        line.set_xy1(trace.h, candle.h_idx, candle.h)
                        line.set_xy2(trace.h, line.get_x1(candle.wick_up), candle.h)

                    if settings.label_show
                        if na(trace.h_l)
                            trace.h_l := label.new(box.get_right(candle.body), candle.h, str.tostring(candle.h), textalign = text.align_center, style = label.style_label_left, size = settings.label_size, color = color_transparent, textcolor = settings.label_color)
                            trace.h_l
                        else
                            label.set_xy(trace.h_l, box.get_right(candle.body), candle.h)
                            label.set_text(trace.h_l, str.tostring(candle.h))

                if bar_index - candle.l_idx < 5000
                    if na(trace.l)
                        trace.l := line.new(candle.l_idx, candle.l, line.get_x1(candle.wick_down), candle.l, xloc = xloc.bar_index, color = settings.trace_l_color, style = helper.LineStyle(settings.trace_l_style), width = settings.trace_l_size)
                        trace.l
                    else
                        line.set_xy1(trace.l, candle.l_idx, candle.l)
                        line.set_xy2(trace.l, line.get_x1(candle.wick_down), candle.l)

                    if settings.label_show
                        if na(trace.l_l)
                            trace.l_l := label.new(box.get_right(candle.body), candle.l, str.tostring(candle.l), textalign = text.align_center, style = label.style_label_left, size = settings.label_size, color = color_transparent, textcolor = settings.label_color)
                            trace.l_l
                        else
                            label.set_xy(trace.l_l, box.get_right(candle.body), candle.l)
                            label.set_text(trace.l_l, str.tostring(candle.l))
    candleSet

if enable_htf
	int cnt = 0
	int last = helper.HTFEnabled()

	int offset = settings.offset
	if htf1.settings.show and helper.ValidTimeframe(htf1.settings.htf)
		bool showTrace = false
		if settings.trace_anchor == 'First Timeframe'
			showTrace := true
			showTrace
		if settings.trace_anchor == 'Last Timeframe' and settings.max_sets == 1
			showTrace := true
			showTrace
		htf1.UpdateTime(offset)
		htf1.Monitor().Update(offset, showTrace).FindImbalance()
		cnt := cnt + 1
		offset := offset + (cnt > 0 ? htf1.candles.size() * settings.width + (htf1.candles.size() > 0 ? (htf1.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer : 0)
		offset
	if htf2.settings.show and helper.ValidTimeframe(htf2.settings.htf) and cnt < last
		bool showTrace = false
		if settings.trace_anchor == 'First Timeframe' and cnt == 0
			showTrace := true
			showTrace
		if settings.trace_anchor == 'Last Timeframe' and cnt == last - 1
			showTrace := true
			showTrace
		htf2.UpdateTime(offset)
		htf2.Monitor().Update(offset, showTrace).FindImbalance()
		cnt := cnt + 1
		offset := offset + (cnt > 0 ? htf2.candles.size() * settings.width + (htf2.candles.size() > 0 ? (htf2.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer : 0)
		offset
	if htf3.settings.show and helper.ValidTimeframe(htf3.settings.htf) and cnt < last
		bool showTrace = false
		if settings.trace_anchor == 'First Timeframe' and cnt == 0
			showTrace := true
			showTrace
		if settings.trace_anchor == 'Last Timeframe' and cnt == last - 1
			showTrace := true
			showTrace
		htf3.UpdateTime(offset)
		htf3.Monitor().Update(offset, showTrace).FindImbalance()
		cnt := cnt + 1
		offset := offset + (cnt > 0 ? htf3.candles.size() * settings.width + (htf3.candles.size() > 0 ? (htf3.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer : 0)
		offset
	if htf4.settings.show and helper.ValidTimeframe(htf4.settings.htf) and cnt < last
		bool showTrace = false
		if settings.trace_anchor == 'First Timeframe' and cnt == 0
			showTrace := true
			showTrace
		if settings.trace_anchor == 'Last Timeframe' and cnt == last - 1
			showTrace := true
			showTrace
		htf4.UpdateTime(offset)
		htf4.Monitor().Update(offset, showTrace).FindImbalance()
		cnt := cnt + 1
		offset := offset + (cnt > 0 ? htf4.candles.size() * settings.width + (htf4.candles.size() > 0 ? (htf4.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer : 0)
		offset
	if htf5.settings.show and helper.ValidTimeframe(htf5.settings.htf) and cnt < last
		bool showTrace = false
		if settings.trace_anchor == 'First Timeframe' and cnt == 0
			showTrace := true
			showTrace
		if settings.trace_anchor == 'Last Timeframe' and cnt == last - 1
			showTrace := true
			showTrace
		htf5.UpdateTime(offset)
		htf5.Monitor().Update(offset, showTrace).FindImbalance()
		cnt := cnt + 1
		offset := offset + (cnt > 0 ? htf5.candles.size() * settings.width + (htf5.candles.size() > 0 ? (htf5.candles.size() - 1) * settings.buffer : 0) + settings.htf_buffer : 0)
		offset
	if htf6.settings.show and helper.ValidTimeframe(htf6.settings.htf) and cnt < last
		bool showTrace = false
		if settings.trace_anchor == 'First Timeframe' and cnt == 0
			showTrace := true
			showTrace
		if settings.trace_anchor == 'Last Timeframe'
			showTrace := true
			showTrace
		htf6.UpdateTime(offset)
		htf6.Monitor().Update(offset, showTrace).FindImbalance()

if enable_sessionsandkillzones
    manage_kz(as_s, use_asian_session, t_as, as_color, as_txt)
    manage_kz(ls_s, use_london_session, t_ls, ls_color, ls_txt)
    manage_kz(nys_s, use_newyork_session, t_ns, nys_color, nys_txt)
    manage_kz(as_kz, use_asia_killzone, t_ak, ak_color, ak_txt)
    manage_kz(lo_kz, use_london_killzone, t_lo, lo_color, lo_txt)
    manage_kz(na_kz, use_nyam_killzone, t_na, na_color, na_txt)
    manage_kz(nl_kz, use_nylu, t_nl, nl_color, nl_txt)
    manage_kz(np_kz, use_nypm_killzone, t_np, np_color, np_txt)

if enable_dwm
    dwm()

if enable_extra_options
    hz_line(use_h1, t_h1, hz_h1, h1_text, h1_color)
    hz_line(use_h2, t_h2, hz_h2, h2_text, h2_color)

if enable_ma
    if use_ma1
        source1 = get_source(source_ma1)
        ma1 := get_ma(type_ma1, source1, length_ma1)
    if use_ma2
        source2 = get_source(source_ma2)
        ma2 := get_ma(type_ma2, source2, length_ma2)
    if use_ma3
        source3 = get_source(source_ma3)
        ma3 := get_ma(type_ma3, source3, length_ma3)
    if use_ma4
        source4 = get_source(source_ma4)
        ma4 := get_ma(type_ma4, source4, length_ma4)

plot(use_ma1 ? ma1 : na, title="MA 1", color=color_ma1, linewidth=1)
plot(use_ma2 ? ma2 : na, title="MA 2", color=color_ma2, linewidth=1)
plot(use_ma3 ? ma3 : na, title="MA 3", color=color_ma3, linewidth=1)
plot(use_ma4 ? ma4 : na, title="MA 4", color=color_ma4, linewidth=1)

// ---------------------------------------- Core Logic --------------------------------------------------